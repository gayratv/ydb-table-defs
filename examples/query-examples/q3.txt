-- Если нужно посчитать число уникальных значений на строках, где выполняется условие, то в отличие от остальных агрегатных функций модификатор DISTINCT тут не поможет, так как в аргументах нет никаких значений. Для получения данного результата, стоит воспользоваться в подзапросе встроенной функцией IF с двумя аргументами (чтобы в else получился NULL), а снаружи сделать COUNT(DISTINCT ...) по её результату.

SELECT COUNT_IF(season_id % 2 == 1) AS odd_count from episodes

-- 59 уникальных title из 67

********************************************************************************************

select Unicode::Find('Cala'u,title)

https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F
********************************************************************************************

^	Начало текста
$	Конец текста
\b	Граница слова
\B	Не граница слова

********************************************************************************************

$grep = Pire::Grep("жні?");

SELECT
    title,
    $grep(title)
from episodes
 where $grep(title)=true

В паттерне могут попадаться символы начала и конца строки (^ и $)

Строка, задающая регулярное выражение, имеет стандартный синтаксис, похожий
на POSIX regexps.
Поддерживаются стандартные возможности (a|b, a*, a+, ., [a-z],
a{3}, a{3,5}, a{3,}) и классы символов (\w (буква), \W (не буква), \d (цифра),
\D (не цифра), \s (whitespace), \S (не whitespace)). Кроме того, могут быть добавлены
операции a&b (пересечение, см. Fsm::operator &) и ~a (инверсия, см. Fsm::Complement).
Помимо этого, для Fsm::SlowCapturingScanner есть возможность использовать нежадные аналоги
повторений - операторы *?, +?, ??. В этом сканере данные операторы будут принимать
как можно более короткие выражения, в отличие от жадных аналогов (которые, наоборот, принимают
как можно более длинные.

В строчке с флагами могут находиться следующие символы:
    * i — нечувствительность к регистру;
    * u — скомпилировать регулярку в UTF-8;
    * s — обрамить регулярку .* с каждой стороны;
    * a — включить поддержку операторов & и ~ в регулярках (см.выше);
    * g — выполнить преобразование fsm = ~fsm.Surrounded() + fsm (для нужд Scan()).

(например, матчить текст
шаблону /id\s*=\s*['"]([a-z0–9]+)['"]/ и извлекать собственно ID).

re = Pire::Lexer("^([a-z]+://)?([A-Za-z0-9\\-]+\\.)*").Parse() + re + Pire::Lexer("(/.*)?$").Parse();


$value = "Вася"u;
$value1="трам та-та";

$grep = Pire::Grep("(?i)^В\\S{1,}я?");
$grep1 = Pire::Grep("(та|ту)?");
$grep2 = Pire::Grep("В[ащ]?");
$grep3 = Pire::Grep("В(ас|ся)?");


SELECT

  $grep($value) AS grep,
  $grep3($value) AS grep1,
