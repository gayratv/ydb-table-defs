https://github.com/google/re2/blob/main/re2/re2.h#L595-L617

Re2::Options(
[
CaseSensitive:Bool?,        // (true)  match is case-sensitive (regexp can override with (?i) unless in posix_syntax mode)
DotNl:Bool?,                // let . match \n (default false)
Literal:Bool?,              // (false) interpret string as literal, not regexp
LogErrors:Bool?,            // (true)  log syntax and execution errors to ERROR
LongestMatch:Bool?,         // (false) search for longest match, not first match
MaxMem:Uint64?,             // (see below)  approx. max memory footprint of RE2
NeverCapture:Bool?,         // (false) parse all parens as non-capturing
NeverNl:Bool?,              // (false) never match \n, even if it is in regexp
PosixSyntax:Bool?,          // (false) restrict regexps to POSIX egrep syntax
Utf8:Bool?,                 // (true)  text and pattern are UTF-8; otherwise Latin-1

// The following options are only consulted when posix_syntax == true.
// When posix_syntax == false, these features are always enabled and cannot be turned off; to perform multi-line matching in that case, begin the regexp with (?m).
PerlClasses:Bool?,          // (false) allow Perl's \d \s \w \D \S \W
WordBoundary:Bool?          // (false) allow Perl's \b \B (word boundary and not)
OneLine:Bool?,              // (false) ^ and $ only match beginning and end of text
])

// The max_mem option controls how much memory can be used
    // to hold the compiled form of the regexp (the Prog) and
    // its cached DFA graphs.  Code Search placed limits on the number
    // of Prog instructions and DFA states: 10,000 for both.
    // In RE2, those limits would translate to about 240 KB per Prog
    // and perhaps 2.5 MB per DFA (DFA state sizes vary by regexp; RE2 does a
    // better job of keeping them small than Code Search did).
    // Each RE2 has two Progs (one forward, one reverse), and each Prog
    // can have two DFAs (one first match, one longest match).
    // That makes 4 DFAs:
    //
    //   forward, first-match    - used for UNANCHORED or ANCHOR_START searches
    //                               if opt.longest_match() == false
    //   forward, longest-match  - used for all ANCHOR_BOTH searches,
    //                               and the other two kinds if
    //                               opt.longest_match() == true
    //   reverse, first-match    - never used
    //   reverse, longest-match  - used as second phase for unanchored searches
    //
    // The RE2 memory budget is statically divided between the two
    // Progs and then the DFAs: two thirds to the forward Prog
    // and one third to the reverse Prog.  The forward Prog gives half
    // of what it has left over to each of its DFAs.  The reverse Prog
    // gives it all to its longest-match DFA.
    //
    // Once a DFA fills its budget, it flushes its cache and starts over.
    // If this happens too often, RE2 falls back on the NFA implementation.

    // For now, make the default budget something close to Code Search.
    static const int kDefaultMaxMem = 8<<20;



$value = "Вася ел банан и сосал сушку"u;
$options = Re2::Options(false AS CaseSensitive);

-- (?P<name>re)    named & numbered capturing group (submatch)
$capture = Re2::Capture(@@.*(?P<foo>ба\S*)@@);

\pL - unicode class letter
Unicode:
Z	separator
Zl	line separator
Zp	paragraph separator
Zs	space separator

$capture = Re2::Capture(@@.*(?P<foo>ба\pL* )@@);

SELECT
  $capture($value) AS capture
  $capture($value).foo AS capture_member,
  $capture($value)._0 AS member0
